:mod:`box_embeddings.modules.pooling.bag_of_boxes`
==================================================

.. py:module:: box_embeddings.modules.pooling.bag_of_boxes


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   box_embeddings.modules.pooling.bag_of_boxes.BagOfBoxesBoxPooler



Functions
~~~~~~~~~

.. autoapisummary::

   box_embeddings.modules.pooling.bag_of_boxes.bag_of_boxes_pooler


.. function:: bag_of_boxes_pooler(boxes: box_embeddings.parameterizations.box_tensor.BoxTensor, mask: Optional[torch.BoolTensor] = None, weights: Optional[torch.Tensor] = None, dim: int = 0, keepdim: bool = False) -> box_embeddings.parameterizations.box_tensor.BoxTensor


.. class:: BagOfBoxesBoxPooler(dim: int = 0, keepdim: bool = False)


   Bases: :class:`box_embeddings.modules.pooling.pooling.BoxPooler`

   Pools a box tensor using hard intersection operation

   .. method:: forward(self, box_tensor: box_embeddings.parameterizations.box_tensor.BoxTensor, mask: torch.BoolTensor = None, weights: torch.BoolTensor = None) -> box_embeddings.parameterizations.box_tensor.BoxTensor

      :param box_tensor: Input
      :param mask: With shape as box_tensor.box_shape[:-1].
                   0 at a position means mask it.
      :param weights: With shape as box_tensor.box_shape[:-1].

      :returns: Pooled output
      :rtype: BoxTensor


   .. method:: register(cls: Type[T], name: str, constructor: str = None, exist_ok: bool = False) -> Callable[([Type[T]], Type[T])]
      :classmethod:

      Transparent method

      :param name: TODO
      :param constructor: TODO
      :param exist_ok: TODO

      :returns: a wrapped callable



