:mod:`box_embeddings.modules.volume.soft_volume`
================================================

.. py:module:: box_embeddings.modules.volume.soft_volume


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   box_embeddings.modules.volume.soft_volume.SoftVolume



Functions
~~~~~~~~~

.. autoapisummary::

   box_embeddings.modules.volume.soft_volume.soft_volume
   box_embeddings.modules.volume.soft_volume.log_soft_volume


.. data:: eps
   :annotation: = 1e-23

   

.. function:: soft_volume(box_tensor: box_embeddings.parameterizations.box_tensor.BoxTensor, beta: float = 1.0, scale: float = 1.0) -> torch.Tensor

   Volume of boxes. Uses softplus instead of ReLU/clamp

   :param box_tensor: input
   :param beta: the beta parameter for the softplus
   :param scale: scale parameter. Should be left as 1.0 (default)
                 in most cases.

   :returns: Tensor of shape (..., ) when self has shape (..., 2, num_dims)

   :raises ValueError: if scale not in (0,1]


.. function:: log_soft_volume(box_tensor: box_embeddings.parameterizations.box_tensor.BoxTensor, beta: float = 1.0, scale: float = 1.0) -> torch.Tensor

   Volume of boxes. Uses softplus instead of ReLU/clamp

   :param box_tensor: input
   :param beta: the beta parameter for the softplus
   :param scale: scale parameter. Should be left as 1.0 (default)
                 in most cases.

   :returns: Tensor of shape (..., ) when self has shape (..., 2, num_dims)

   :raises ValueError: if scale not in (0,1]


.. class:: SoftVolume(log_scale: bool = True, beta: float = 1.0)


   Bases: :class:`box_embeddings.modules.volume.volume.Volume`

   Softplus based volume.

   .. attribute:: default_implementation
      :annotation: = hard

      

   .. method:: forward(self, box_tensor: box_embeddings.parameterizations.box_tensor.BoxTensor) -> torch.Tensor

      Soft softplus base (instead of ReLU) volume.

      :param box_tensor: TODO

      :returns: torch.Tensor


   .. method:: register(cls: Type[T], name: str, constructor: str = None, exist_ok: bool = False) -> Callable[([Type[T]], Type[T])]
      :classmethod:

      Transparent method

      :param name: TODO
      :param constructor: TODO
      :param exist_ok: TODO

      :returns: a wrapped callable



